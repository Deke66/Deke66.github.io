---
layout: post
title: synchronized
category: Java语言
tags: synchronized
keywords: java,synchronized
---
## 作用
- 在多线程之间进行同步，同步块代码一次只能被一个线程执行
- synchronized可以用在方法或者对象上：
   1. 修饰静态方法，进入该静态方法需获得当前Class对象的锁
   2. 修饰普通方法，进入该方法需获取当前对象的锁
   3. 用在对象上，进入同步块需获取对象的锁

## 同步策略


###  互斥同步（阻塞同步）
- 同步是指多个线程并发访问共享数据时，保证同一时刻只被-个（或者是一些，使用信号量的时候）线程使用
- 互斥是实现同步的一种手段，可以通过临界区，互斥量和信号量实现互斥
- 实现互斥同步主要通过synchronized关键字
- 轻量级锁膨胀为重量级锁

### 非阻塞同步
- 在一定时间内通过消耗CPU时间片不停地重试以获得同步代码块的执行权，一般基于CPU的CAS指令



## 实现原理
- synchronized关键字经过编译后，会在同步块代码前后分别形成monitorenter和monitorexit两个字节码指令
- 根据虚拟机规范，执行monitorenter指令先尝试获取对象锁，成功获取锁，则锁的计数器加1，执行monitorexit指令会将锁的计数器减1，计数器为0时，锁进行释放

## 锁优化

### 自旋锁和适应性自旋
- 自旋锁：线程不放弃CPU时间片，先进行忙循坏等待，之后重新尝试获取锁
- 适应性自旋锁：根据程序的运行情况，调整自旋时间

### 锁消除
- 程序运行期间，同步代码被检测到不可能存在共享数据竞争锁的情况，则进行锁消除
- 锁消除判定依据来源于逃逸分析的数据支持

### 锁粗化
- 一个简单的例子如采用StringBuffer进行字符串连接时，会将小的同步代码块合并成一个大的同步代码块，即同步代码块为StringBuffer的第一个连接对象到最后一个连接对象

### 轻量级锁
- Java中的对象在堆中存放的连续数据包括：对象头，实例数据和填充数据，synchronized主要是对对象头数据进行操作。
- 对象头的数据包括：Mark Word，class pointer和array length（对象是一个数组的时候才设立）
- Mark Word

| 存储内容 | 标志位 | 状态 |
| ------- | ------- | ------- |
| 对象哈希码，对象分代年龄 | 01 | 未锁定 |
| 指向锁记录的指针 | 00 | 轻量级锁定 |
| 指向重量级锁的指针 | 10 | 膨胀（重量级锁定） |
| 空 | 11 | GC标记 |
| 偏向线程ID，偏向时间戳，对象分代年龄等 | 01 | 可偏向 |

- 加锁过程：
   1. 进入同步块时，此同步对象01状态，同时在该线程栈帧建立锁记录（Lock Record）空间，存储对象当前的Mark Word的拷贝
   2. 虚拟机使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针
   3. 更新成功，该线程获得锁，标志位为00
   4. 更新失败，先检查对象的Mark Word是否指向该线程的栈帧Lock Record，如果是同样获得了锁，进入同步块执行
   5. 如果两个以上的线程争这个对象的锁，轻量级锁将膨胀为重量级锁
- 解锁过程：
   1. 通过CAS操作把对象当前的Mark Word和线程中复制的Mark Word替换，替换成功，同步过程完毕
   2. 替换失败，即其他线程尝试过获取该锁，释放锁的同时，唤醒被挂起的线程（替换失败说明锁已经膨胀为重量级锁）


### 偏向锁
- 锁对象第一次被线程获取的时候，标志位设为01，同时利用CAS操作把该线程ID记录在对象的Mark Word中，CAS操作成功，持有偏向锁的线程以后进入该同步块不进行任何同步操作，即该线程再次进入比较偏向线程ID即可
- 另外一个线程尝试获取锁，则偏向模式结束
- 根据锁对象目前锁定状态，恢复到01或00

## 偏向锁，轻量级锁的额外损耗
1. 偏向锁可以提高带有同步但无竞争的程序性能；反之，大多数时间多线程竞争激烈的情况，偏向模式是多余的
2. 轻量级锁在没有竞争，使用CAS避免互斥量同步开销；在存在竞争，多了CAS操作，有竞争的情况下，轻量级锁比传统的重量级锁慢

## 参考
- 深入理解Java虚拟机











