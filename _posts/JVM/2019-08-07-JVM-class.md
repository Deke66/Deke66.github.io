---
layout: post
title: JVM类加载
category: JVM
tags: JVM
keywords: JVM
---
## 类的生命周期
- 加载 验证 准备 解析 初始化 使用 卸载

### 加载
- 通过类的全限定名来获取定义此类的二进制字节流
- 将字节流所代表的静态存储结构转化为方法区的运行时的数据结构
- 在内存生成class对象，访问方法区类的各种数据结构的入口

### 验证
- 对类文件内容的验证：确保 Class文件的字节流符合当前虚拟机要求，不会危害虚拟机自身安全。
- 包括文件格式验证，元数据验证，字节码验证，符号引用验证。
	1. 文件格式验证：验证字节流是否符合Class文件格式的规范，比如是否已魔数0xCAFEBABE开头，主次版本是否在当前虚拟机处理范围之内等
	2. 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范，比如这个类是否由父类（除Object之外）等
	3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的
	4. 符号引用验证：发生在虚拟机减符号引用转化为直接引用的时候，主要校验符号引用中通过字符串描述的全限定名是否能找到对应的类等

### 准备
- 正式为类变量分配内存并设置初始值，这些变量所使用的内存都将在方法区中进行分配。初始值非程序设定的初始值，而是基本类型int初始值为0或者引用类型初始值为null，特殊情况例外（如final类型）

### 解析
- 虚拟机将常量池内的符号引用替换为直接引用的过程
	1. 符号引用：以一组符号来描述所引用的目标
	2. 直接引用：直接指向目标的指针，相对偏移量或是一个能简介定位到目标的句柄
- 主要包括以下解析
	1. 类或接口的解析
	2. 字段解析
	3. 类方法解析
	4. 接口方法解析

### 初始化
- 真正执行类中定义的Java程序代码
- 触发条件（Java虚拟机规范约定）：
	1. 遇到new，getstatic，putstatic或invokestatic这4条字节码指令，如果没有对类初始化，需要先触发初始化：使用new实例化对象，读取或设置类的静态字段（被final修饰除外），调用类的静态方法
	2. 对类进行反射调用
	3. 初始化子类，先触发父类的初始化
	4. 虚拟机启动触发执行主类
	5. 如果-个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_Static,REF_invokeStatic的方法句柄，触发对应类的初始化
- 从代码角度看：初始化阶段是执行类构造器<clinit>()方法的过程
	1. <clinit>()方法是编译器自动收集类中所有类变量的赋值操作和静态语句块中的语句合并产生，执行顺序按照语句在源文件中出现的顺序，静态语句块只能访问到定义在金泰语句块之前的变量
	2. <clinit>()方法与类的构造函数不同，不需要显式调用父类构造器，虚拟机保证父类的<clinit>()方法在子类执行之前
	3. 父类定义的静态语句块要优于子类的变量赋值操作
	4. <clinit>()方法对于类或接口不是必需的，即如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为此类生成此方法
	5. 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，接口也会生成<clinit>()方法，但与类不同，执行接口的<clinit>()方法不需要执行父接口的<clinit>()方法不需要执行父接口的
	6. 虚拟机保证<clinit>()方法在多线程环境中的正确性
	
## 类加载器
- 从虚拟机角度分析，两种类加载器
	1. 启动类加载器（Bootstrap ClassLoader），采用C++语言实现，作为虚拟机自身的一部分
	2. 独立于虚拟机外部的类加载器，由Java语言实现，继承于java.lang.ClassLoader 
- 从Java开发人员角度分析，3种类加载器
	1. 启动类加载器：加载JAVA_HOME/lib下的文件或-Xbootclasspath参数指定的路径下的
	2. 扩展类加载器：加载JAVA_HOME/lib/ext目录下的，或者系统变量java.ext.dirs指定的
	3. 应用程序类加载器：加载用户类路径上指定的烈苦

### 双亲委派模型
- 定义：
	1. 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而把此请求委托给父类加载器去完成，
	2. 每一层次的加载器都如此，只有当父类加载器反馈无法加载，子加载器才尝试加载
- 优点：
	1. 防止核心class文件被篡改


### OSGi-类加载器不遵循双亲委派模型
- 收到类加载请求，OSGi进行类搜索的方式
	1. 以java.开头的类委派给父类加载器加载
	2. 否则，以委派列表名单内的类委派给父类加载器加载
	3. 否则，将Import列表中的类委派给父类加载器加载
	4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载
	5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
	6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载
	7. 否则查找失败
	
## 参考
- 深入理解Java虚拟机



 


	





 

