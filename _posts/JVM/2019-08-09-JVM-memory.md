---
layout: post
title: JVM内存模型
category: JVM
tags: JVM
keywords: JVM
---
## 概述
- Java虚拟机执行Java程序过程把它管理的内存划分为若干各不同的数据区域（运行时数据区域），主要包括方法区，虚拟机栈，本地方法栈，堆和程序计数器

## 程序计数器
- 内存空间较小，可看作当前线程所执行的字节码的行号指示器
- 线程独占，各线程计数器互不影响
- 执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址
- 执行native方法，计数器值为空
- 唯一无OutOfMemoryError的区域

## Java虚拟机栈
- 线程独占
- Java方法执行创建栈帧，存储局部变量表，操作数栈，动态链接和方法入口等信息
- 局部变量表存放编译器确定的值（包括基本数据类型和对象的引用），所需内存空间在编译期已确定
- 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常
- 栈扩展内存不足，抛出OutOfMemoryError异常

## 本地方法栈
- 与Java虚拟机栈类似，本地方法栈主要执行native方法

## Java堆
- 线程共享，内存空间较大，主要存放对象实例
- 从GC角度来看，堆可分为新生代和老年代，再细分可分为Eden，From Survivor，ToSurivivor空间等
- 从内存分配角度来看，堆可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）
- 内存不够，会抛出OutOfMemoryError异常
- -Xms可以指定初始化的堆大小
- -Xmx可以指定最大堆的大小

## 方法区
- 线程共享
- 存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

### 运行时常量池
- 存放编译器生成的各种字面量和符号引用
- String类的intern（）方法可以在运行期间将常量放入常量池
- <=1.6,常量池直接存放字符串数据，>1.6 字符串首次创建在堆中，常量池存储String对象的引用

## 直接内存
- 非运行时数据区域，不属于Java虚拟机规范中定义的内存区域
- 使用Native函数库直接分配堆外内存，通过Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作
- 可在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回赋值数据

## Java对象创建与内存分配

### new指令
1. 检查指令的参数是否能在常量池中定位到该类的符号引用
2. 检查该符号引用代表的类是否已被加载，解析和初始化
3. 如果没有执行类的加载过程

### 内存分配
- 对象所需内存大小在类加载完成后可完全确定
- 内存绝对规整，可以让分配的内存放一起，空闲内存放一起（指针碰撞）
- 内存不规整，需使用空闲列表记录空闲内存（空闲列表）
- 并发安全保证
	- 同步策略（基于CAS分配失败重试）
	- 本地线程分配缓冲（TLAB）：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，TLAB用完并分配新的TLAB采用同步锁定
	
## 对象访问
- 句柄访问：堆划分出一块内存作为句柄池，栈中存放的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体信息
- 指针指针访问：栈中存放堆中对象的地址

## 参考
- 深入理解Java虚拟机




 

