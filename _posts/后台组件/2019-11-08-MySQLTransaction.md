---
layout: post
title: MySQL事务
category: 后台组件
tags: MySQL
keywords: MySQL
---
## 事务
- 事务是由一组 SQL 语句组成的逻辑处理单元

## 事务ACID
1. 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
2. 一致性（Consistent）：
	1. 在事务开始和完成时，数据都必须保持一致状态。
	2. 这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；
	3. 事务结束时，所有的内部数据结构（如 B 树索引或双向链表）也都必须是正确的。 
3. 隔离性（Isolation）：
	1. 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。
	2. 这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
4. 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 事务的并发问题
1. 更新丢失（Lost Update）
	1. 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题
	2. 最后的更新覆盖了由其他事务所做的更新。
	3. 例如，两个编辑人员制作了同一文档的电子副本。
	4. 每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。
	5. 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。
	6. 如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。
2.  脏读（Dirty Reads）
	1. 一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；
	2. 这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。
3. 不可重复读（Non-Repeatable Reads）
	1. 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！
4.  幻读（Phantom Reads）
	1. 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据
	
- 小结
	1. 更新丢失问题应由应用处理
	2. 脏读，不可重复读，幻读属于数据库读一致性问题，应由数据库提供一定的事务隔离机制来解决
	
## 事务隔离级别->一定程度上解决事务并发问题

隔离级别|读数据一致性|脏读|不可重复读|幻读
---|--|---
未提交读|最低级别，只能保证不读取物理上损坏的数据|是|是|是
已提交读|语句级|否|是|是
可重复读|事务级|否|否|是
可序列化|最高级别|否|否|否

## 事务与InnoDB锁
1. 行锁—>通过给索引上的索引项加锁
	1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 
	2. 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
2. 表锁
	1. 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
	2. 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。 

3. 兼容性关系

请求锁\当前锁 |X|IX|S|IS
---|:--:|---:
X|冲突|冲突|冲突|冲突
IX|冲突|兼容|冲突|兼容
S|冲突|冲突|兼容|兼容
IS|冲突|兼容|兼容|兼容

4. 如果一个事务请求的锁模式与当前的锁模式兼容，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。
5. 意向锁是 InnoDB 自动加的，不需用户干预。
6. 对于 UPDATE、DELETE 和 INSERT 语句，InnoDB会自动给涉及数据集加排他锁（X)；
7. 对于普通 SELECT 语句，InnoDB 不会加任何锁；
8. 事务可以通过以下语句显示给记录集加共享锁或排他锁。 
	1. 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 
	2. 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。
9. 间隙锁：
	1. 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的 索引项加锁；
	2. 对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB 也会对这个“间隙”加锁
	3. 主要是防止幻读的问题来满足不同隔离级别的要求 














 









